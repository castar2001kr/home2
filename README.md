# draw_and_guess
draw_and_guess game
///////////////////////////////////////////////////////////////////////////////////////

게임은 이벤트 발생과 처리의 연속이다.


///////////////////////////////////////////////////////////////////////////////////////

1. directory : game - JS
socket 인터페이스를 이용하여 소켓을 생성하고 인터페이스의 함수를 바꾸어가며 이벤트를 교체한다.

socket에 전달되는 메시지들은 JSON 형식으로,
{
  header : {type : //0(클라이언트 - 호스트로 가는 메시지) // 1(wait 모드로 전환하라는 신호) // 2(sw-host()) 
  // 3(sw-client) // 5(클라이언트가 호스트 또는 클라이언트로 모드를 변화시켰다는 메시지)} // 7(호스트 메시지) // 8(정답 메시지)
  
  body : // 메시지의 내용이 담긴다

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Info는 state를 통하여 활성화가 되었는 지 안되었는 지 판단된다.
잘못된 InfoSet에 접근할 때, state를 통해 잘못된 접근인지를 판별한다.

IdGenerator는 Info 객체들에 접근하기 위한 각각의 주소들을 전달한다.
이때, 발행되는 Id는 큐에 있는 순서대로 나오지만, 그 수에는 제한(size 변수로 통제)이 있다.
IdGenerator에서 할당 받은 id를 통하여 접근하여 생성, 삭제, 조회가 되기 때문에
동시적으로 동일한 메모리의 부분에 Info객체가 생성되거나 삭제되거나 조회되는 일은 없다.

IdGenerator는 탐색 노드를 제공한다.
탐색노드는 읽기작업에선 동기화하지 않아 빠르게 노드를 따라 읽을 수 있다.
단, 삭제와 삽입이 동시에 이루어지지 않게 HashMap 동기화를 통해 동시성이 통제된다.
HashMap을 통하여 연결된 노드들을 앞에서 부터 접근하기 때문에,
삭제가 이루어진 뒤에는 항상 정보가 최신되는 것이 보장된다.
삽입을 할 때는 HashMap을 동기화하여 다른 삽입과 삭제가 동시에 이루어지지 않게 한다.

탐색노드는 InfoSet 배열에 접근하는 것과 직접적으로는 상관없다.
InfoSet 배열에 접근하기 전에, 탐색노드들을 검색하는 순간 활성화된 Info를 알려주는 정보들이다.
직접적으로 InfoSet에 접근하여 Info를 가져오는 것은 따로 이루어지는 행위이다.

Info<E>의 내용(E)을  수정하는데는 Info를 꼭 동기화 해야 한다.
그래야 다른 부분에서 state가 바뀔 때나 내용이 바뀔 때, 알 수 있다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RoomManager는 이러한 IdGenerator의 속성을 통해 
방 생성, 방 개수 통제, 방 조회를 하도록 한다.

/////////////////////////////////////////////////////////////////
Room은 IdGenerator를 통해 인원참가, 탈퇴, 인원 조회를 제공한다.
단, 참가와 탈퇴를 할 때, Room 자체를 동기화 시켰다. => synchronized(room)을 통함.
이유는 방 탈퇴시, 호스트이면 호스트 권한을 다른 인원에게 넘겨야 하며, 게임을 중단하거나
각 클라이언트들에게 알려야하기 때문에 순서 제한이 있어야 되기 때문이다.
//////////////////////////////////////////////////////////////////

Room은 여러 프로세스들과 액션 라우터와 메시지 라우터를 통하여 게임을 진행한다.
프로세스는 게임에서 이루어지는 작업들의 단위이다.(모든 행위들의 단위이다. 나가기, 들어오기,
호스트의 그림 전송, 채팅 메시지 전송, 정답 맞추기, 게임 진행 멈추기, 게임 시작하기, 호스트
변경 알림 등등)

액션 라우터는 이러한 프로세스들이 실행되게 하는 인터페이스이다.
액션라우터를 통해 프로세스가 이루어지는 것이다.

파일들을 보면, 액션 라우터들이 프로세스들을 묶어둔 것을 볼 수 있다.
묶음 단위로 이루어져야하는 프로세스들을 묶거나, 입장과 탈퇴, 호스트 변경알림과 같은 여러 가지
단위들은 순서가 있게 이루어져야 하기 때문에 동기화를 통하여 순서있게 실행되도록 통제하기도 한다.
또한, 타이머 기능도 있어서 게임의 제한시간도 이 라우터를 통하여 통제하도록 한다.
왜냐하면 게임이 끝나거나 다시 시작될 때, 단순히 게임이 진행되는 프로세스를 다시 생성하거나 차단하여 통제하면 되기 때문이다.

메시지 라우터는 Room으로 들어오는 여러가지 메시지들을 JSONParser로 검열하고, 
필요한 액션 라우터를 실행시킨다.
호스트의 게임진행, 드로잉 메시지 , 채팅 메시지들을 라우팅시키는 작업이다.

//////////////////////////////////////////////////////////////////

gameIO.js 파일은 웹소켓에 의한 화면단의 이벤트를 구성한다.

drawer_for_client는 소켓으로 들어온 정보를 캔버스에 그리게 해준다.
drawer_for_host는 캔버스에 그린 그림을 딜레이, 좌표, 액션으로 데이터화 시켜서 보낸다.

Router는 웹소켓의 메시지들을 처리해야 할 연산, 액션으로 유도한다.

Socket인터페이스는 위의 오브젝트들을 생성하고 접근할 수 있는 가장 첫 번째로 생성되는 객체의 클래스이다.

//////////////////////////////////////////////////////////////////////////////////////

ajax 요청으로 구현해야할 Mypid  화면단의 정보들과 화면 레이아웃 구성, 이벤트로 인한 화면 변화 ,URI 설계만 남았다.
그림 정보는 이미 구현이 끝남.

//////////////////////////////////////////////////////////////////////////////////////////////////////








